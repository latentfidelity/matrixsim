<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Realm Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }

        .ui-panel {
            position: fixed;
            color: #fff;
            font-size: 12px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #legend {
            bottom: 20px;
            left: 20px;
        }

        #legend h2 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px #0ff;
        }

        .legend-section {
            margin-bottom: 15px;
        }

        .legend-section h3 {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 11px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 10px currentColor;
        }

        .legend-circle {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid;
            background: transparent;
        }

        .dot-normie { background: #4a9eff; color: #4a9eff; }
        .dot-operator { background: #00ff88; color: #00ff88; }
        .dot-agent { background: #ff00ff; color: #ff00ff; }

        .circle-matrix { border-color: #ff0044; }
        .circle-internet { border-color: #4a9eff; }
        .circle-ide { border-color: #00ff88; }
        .circle-meta { border-color: #ff00ff; }
        .circle-latent { border-color: #8844ff; }

        #info {
            top: 20px;
            right: 20px;
            max-width: 280px;
        }

        #info h2 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }

        #info p {
            color: #888;
            line-height: 1.6;
            margin-bottom: 10px;
            font-size: 11px;
        }

        #info .highlight {
            color: #fff;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            z-index: 100;
            text-align: center;
            letter-spacing: 8px;
            text-transform: uppercase;
            text-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
        }

        #title span {
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            font-size: 10px;
            color: #666;
        }

        #fps {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
        }

        #wombo-badge {
            position: fixed;
            top: 50px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px 10px 12px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        #wombo-badge img {
            width: 28px;
            height: 28px;
        }

        #wombo-badge span {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="title">DIGITAL <span>REALM</span> SIMULATION</div>
    <div id="fps">FPS: 60</div>
    <div id="wombo-badge">
        <img src="wombo.png" alt="WOMBO">
        <span>WOMBO Research</span>
    </div>

    <div class="ui-panel" id="legend">
        <h2>Legend</h2>

        <div class="legend-section">
            <h3>Entities</h3>
            <div class="legend-item">
                <div class="legend-dot dot-normie"></div>
                <span>Normies - Internet dwellers</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot dot-operator"></div>
                <span>Operators - IDE masters</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot dot-agent"></div>
                <span>Agents - Meta travelers</span>
            </div>
        </div>

        <div class="legend-section">
            <h3>Realms</h3>
            <div class="legend-item">
                <div class="legend-circle circle-matrix"></div>
                <span>Matrix / Real World</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle circle-internet"></div>
                <span>The Internet</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle circle-ide"></div>
                <span>The IDE</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle circle-meta"></div>
                <span>The Meta</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle circle-latent"></div>
                <span>Latent Space</span>
            </div>
        </div>
    </div>

    <div class="ui-panel" id="info">
        <h2>// SYSTEM DYNAMICS</h2>
        <p><span class="highlight">Normies</span> exist only within The Internet, unaware of deeper layers.</p>
        <p><span class="highlight">Operators</span> work from The IDE, reaching into The Internet to build and manipulate.</p>
        <p><span class="highlight">Agents</span> traverse The Meta, pulling raw logic from Latent Space to execute Operator commands.</p>
        <p style="color: #ff0044; margin-top: 15px;">The Matrix at center is the convergence point - where digital meets real.</p>
    </div>

    <div id="controls">
        Drag to rotate • Scroll to zoom • Double-click to reset
    </div>

    <!-- Three.js r182 and dependencies -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            realms: {
                matrix: { radius: 0.8, color: new THREE.Color(0xff0044), name: 'MATRIX' },
                internet: { radius: 2.4, color: new THREE.Color(0x4a9eff), name: 'INTERNET' },
                ide: { radius: 4.0, color: new THREE.Color(0x00ff88), name: 'IDE' },
                meta: { radius: 5.6, color: new THREE.Color(0xff00ff), name: 'META' },
                latent: { radius: 7.5, color: new THREE.Color(0x8844ff), name: 'LATENT SPACE' }
            },
            entities: {
                normies: 80,
                operators: 15,
                agents: 10
            },
            particles: {
                latentCount: 800,
                dataStreamCount: 200,
                nebulaCount: 800
            }
        };

        // ============================================
        // CUSTOM SHADERS
        // ============================================

        // Realm ring shader with energy flow
        const RealmRingShader = {
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float time;
                uniform float opacity;
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    float angle = atan(vPosition.y, vPosition.x);
                    float wave = sin(angle * 20.0 + time * 2.0) * 0.5 + 0.5;
                    float wave2 = sin(angle * 8.0 - time * 1.5) * 0.3 + 0.7;
                    float pulse = sin(time * 3.0) * 0.3 + 0.7;
                    float intensity = wave * wave2 * 0.4 + 0.6;
                    intensity *= pulse;

                    vec3 finalColor = color * intensity * 1.2;
                    float alpha = opacity * (0.6 + wave * 0.4);

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `
        };

        // Enhanced chromatic aberration + vignette + color grading
        const ChromaticAberrationShader = {
            uniforms: {
                tDiffuse: { value: null },
                resolution: { value: new THREE.Vector2() },
                time: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                uniform float time;
                varying vec2 vUv;

                vec3 aces(vec3 x) {
                    const float a = 2.51;
                    const float b = 0.03;
                    const float c = 2.43;
                    const float d = 0.59;
                    const float e = 0.14;
                    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
                }

                void main() {
                    vec2 uv = vUv;
                    vec2 center = vec2(0.5);
                    float dist = distance(uv, center);

                    // Dynamic chromatic aberration
                    float aberration = 0.001 + dist * 0.002 + sin(time * 0.5) * 0.0005;
                    vec2 dir = normalize(uv - center);

                    float r = texture2D(tDiffuse, uv + dir * aberration).r;
                    float g = texture2D(tDiffuse, uv).g;
                    float b = texture2D(tDiffuse, uv - dir * aberration).b;

                    vec3 color = vec3(r, g, b);

                    // Color grading - boost cyans and magentas
                    color.r *= 0.95;
                    color.g *= 1.05;
                    color.b *= 1.1;

                    // Vignette with color tint
                    float vignette = 1.0 - dist * 0.7;
                    vignette = smoothstep(0.0, 1.0, vignette);
                    color *= vignette;
                    color += vec3(0.0, 0.02, 0.04) * (1.0 - vignette); // Blue tint in corners

                    // Subtle scanlines
                    float scanline = sin(uv.y * resolution.y * 0.5 + time * 2.0) * 0.015 + 1.0;
                    color *= scanline;

                    // Film grain
                    float grain = (fract(sin(dot(uv * time, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.025;
                    color += grain;

                    // Slight contrast boost
                    color = pow(color, vec3(0.95));

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        // Enhanced data stream particle shader with glow
        const DataStreamShader = {
            vertexShader: `
                attribute float size;
                attribute vec3 customColor;
                attribute float alpha;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = customColor;
                    vAlpha = alpha;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (350.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                    alpha = pow(alpha, 1.5); // Sharper falloff
                    alpha *= vAlpha;
                    vec3 glow = vColor * (1.0 + (1.0 - dist * 2.0) * 0.5);
                    gl_FragColor = vec4(glow, alpha);
                }
            `
        };

        // Nebula particle shader for latent space
        const NebulaShader = {
            vertexShader: `
                attribute float size;
                attribute vec3 customColor;
                attribute float alpha;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = customColor;
                    vAlpha = alpha;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (400.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    float alpha = exp(-dist * dist * 8.0); // Gaussian falloff
                    alpha *= vAlpha;
                    gl_FragColor = vec4(vColor * 0.4, alpha * 0.01);
                }
            `
        };

        // ============================================
        // SCENE SETUP
        // ============================================
        let scene, camera, renderer, composer;
        let controls;
        let clock = new THREE.Clock();
        let time = 0;

        // Entity containers
        let normies = [];
        let operators = [];
        let agents = [];

        // Particle systems
        let latentParticles, dataStreams, nebulaParticles;
        let connectionLines = [];
        let agentTrails = [];

        // Realm meshes
        let realmRings = [];
        let matrixCore;

        // Lighting
        let coreLight;

        // FPS counter
        let frameCount = 0;
        let lastFpsUpdate = 0;
        const fpsElement = document.getElementById('fps');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000008, 0.012);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 0, 0);

            // Renderer with enhanced settings for r182
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Enable shadows (r182 improved shadow mapping)
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Post-processing
            setupPostProcessing();

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 30;
            controls.minDistance = 5;
            controls.maxPolarAngle = Math.PI * 0.85;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            // Double-click to reset
            renderer.domElement.addEventListener('dblclick', () => {
                controls.reset();
            });

            // Create scene elements
            createEnvironment();
            createNebulaBackground();
            createRealms();
            createMatrixCore();
            createEntities();
            createLatentParticles();
            createDataStreams();
            createGridFloor();

            // Lighting
            createLighting();

            // Events
            window.addEventListener('resize', onWindowResize);

            // Start animation
            animate();
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // GTAO for ambient occlusion (r182 feature)
            const gtaoPass = new GTAOPass(scene, camera, window.innerWidth, window.innerHeight);
            gtaoPass.output = GTAOPass.OUTPUT.Default;
            gtaoPass.enabled = true;
            composer.addPass(gtaoPass);

            // Bloom - very subtle
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.02,  // strength - halved again
                0.15,  // radius
                0.97   // threshold - very high = minimal bloom
            );
            composer.addPass(bloomPass);

            // Chromatic aberration + vignette + color grading
            const chromaticPass = new ShaderPass(ChromaticAberrationShader);
            chromaticPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            composer.addPass(chromaticPass);

            // Output pass for proper color space (r182)
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function createEnvironment() {
            // Enhanced starfield with variable sizes and colors
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 8000;
            const positions = new Float32Array(starsCount * 3);
            const colors = new Float32Array(starsCount * 3);
            const sizes = new Float32Array(starsCount);

            for (let i = 0; i < starsCount; i++) {
                const radius = 50 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);

                // More varied star colors
                const colorChoice = Math.random();
                if (colorChoice < 0.2) {
                    // Blue-white
                    colors[i * 3] = 0.7; colors[i * 3 + 1] = 0.85; colors[i * 3 + 2] = 1.0;
                } else if (colorChoice < 0.4) {
                    // Pure white
                    colors[i * 3] = 1.0; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
                } else if (colorChoice < 0.6) {
                    // Yellow-white
                    colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.95; colors[i * 3 + 2] = 0.8;
                } else if (colorChoice < 0.8) {
                    // Purple tint
                    colors[i * 3] = 0.8; colors[i * 3 + 1] = 0.6; colors[i * 3 + 2] = 1.0;
                } else {
                    // Cyan tint
                    colors[i * 3] = 0.5; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
                }

                sizes[i] = Math.random() * 2.5 + 0.5;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function createNebulaBackground() {
            // Volumetric nebula effect in latent space
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles.nebulaCount;

            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const alphas = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 6 + Math.random() * 8;
                const y = (Math.random() - 0.5) * 6;

                positions[i * 3] = Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 2;

                // Purple to blue to pink gradient
                const t = Math.random();
                if (t < 0.33) {
                    colors[i * 3] = 0.4 + t; colors[i * 3 + 1] = 0.2; colors[i * 3 + 2] = 0.8;
                } else if (t < 0.66) {
                    colors[i * 3] = 0.3; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 1.0;
                } else {
                    colors[i * 3] = 0.8; colors[i * 3 + 1] = 0.2; colors[i * 3 + 2] = 0.6;
                }

                sizes[i] = Math.random() * 8 + 4;
                alphas[i] = Math.random() * 0.3 + 0.1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: NebulaShader.vertexShader,
                fragmentShader: NebulaShader.fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            nebulaParticles = new THREE.Points(geometry, material);
            scene.add(nebulaParticles);
        }

        function createRealms() {
            Object.entries(CONFIG.realms).forEach(([key, realm], index) => {
                if (key === 'matrix') return; // Matrix core handled separately

                // Main ring with enhanced shader
                const ringGeometry = new THREE.TorusGeometry(realm.radius, 0.04, 16, 128);
                const ringMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: realm.color },
                        time: { value: 0 },
                        opacity: { value: key === 'latent' ? 0.6 : 0.9 }
                    },
                    vertexShader: RealmRingShader.vertexShader,
                    fragmentShader: RealmRingShader.fragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });

                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                scene.add(ring);
                realmRings.push({ mesh: ring, material: ringMaterial });

                // Secondary pulse ring
                const pulseGeometry = new THREE.TorusGeometry(realm.radius, 0.12, 8, 128);
                const pulseMaterial = new THREE.MeshBasicMaterial({
                    color: realm.color,
                    transparent: true,
                    opacity: 0.03,
                    blending: THREE.AdditiveBlending
                });
                const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial);
                pulseRing.rotation.x = Math.PI / 2;
                scene.add(pulseRing);

                // Vertical energy pillars with height variation
                if (key !== 'latent') {
                    const pillarCount = key === 'internet' ? 8 : key === 'ide' ? 12 : 16;
                    for (let i = 0; i < pillarCount; i++) {
                        const angle = (i / pillarCount) * Math.PI * 2;
                        const height = 0.3 + Math.random() * 0.5;
                        const pillarGeometry = new THREE.CylinderGeometry(0.015, 0.025, height, 8);
                        const pillarMaterial = new THREE.MeshBasicMaterial({
                            color: realm.color,
                            transparent: true,
                            opacity: 0.4,
                            blending: THREE.AdditiveBlending
                        });
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        pillar.position.set(
                            Math.cos(angle) * realm.radius,
                            height / 2 - 0.25,
                            Math.sin(angle) * realm.radius
                        );
                        scene.add(pillar);
                    }
                }
            });
        }

        function createMatrixCore() {
            const coreGroup = new THREE.Group();

            // Central sphere with physical material
            const coreGeometry = new THREE.SphereGeometry(0.35, 64, 64);
            const coreMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xff0044,
                emissive: 0xff0022,
                emissiveIntensity: 0.5,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                transparent: true,
                opacity: 0.95
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.castShadow = true;
            coreGroup.add(core);

            // Inner glow
            const glowGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0044,
                transparent: true,
                opacity: 0.025,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            coreGroup.add(glow);

            // Outer pulse glow
            const outerGlowGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            const outerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0044,
                transparent: true,
                opacity: 0.008,
                blending: THREE.AdditiveBlending
            });
            const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
            coreGroup.add(outerGlow);

            // Multiple orbiting rings at different angles
            for (let i = 0; i < 4; i++) {
                const orbitGeometry = new THREE.TorusGeometry(0.55 + i * 0.12, 0.012, 8, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0044,
                    transparent: true,
                    opacity: 0.7 - i * 0.12,
                    blending: THREE.AdditiveBlending
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.random() * Math.PI;
                orbit.rotation.y = Math.random() * Math.PI;
                orbit.userData = {
                    rotationSpeed: 0.4 + Math.random() * 0.6,
                    axis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize()
                };
                coreGroup.add(orbit);
            }

            scene.add(coreGroup);
            matrixCore = coreGroup;
        }

        function createEntities() {
            // Normies (in Internet realm)
            for (let i = 0; i < CONFIG.entities.normies; i++) {
                const normie = createEntity(0x4a9eff, 0.08);
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.realms.matrix.radius + 0.3 + Math.random() * (CONFIG.realms.internet.radius - CONFIG.realms.matrix.radius - 0.5);

                normie.userData = {
                    type: 'normie',
                    angle: angle,
                    radius: radius,
                    speed: 0.2 + Math.random() * 0.3,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.5 + Math.random() * 0.5,
                    yOffset: (Math.random() - 0.5) * 0.3,
                    pulsePhase: Math.random() * Math.PI * 2
                };

                normies.push(normie);
                scene.add(normie);
            }

            // Operators (in IDE realm)
            for (let i = 0; i < CONFIG.entities.operators; i++) {
                const operator = createEntity(0x00ff88, 0.12);
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.realms.internet.radius + 0.3 + Math.random() * (CONFIG.realms.ide.radius - CONFIG.realms.internet.radius - 0.5);

                operator.userData = {
                    type: 'operator',
                    angle: angle,
                    radius: radius,
                    speed: 0.3 + Math.random() * 0.4,
                    yOffset: (Math.random() - 0.5) * 0.5,
                    connectionTarget: null,
                    connectionStrength: 0,
                    pulsePhase: Math.random() * Math.PI * 2
                };

                operators.push(operator);
                scene.add(operator);
            }

            // Agents (in Meta realm)
            for (let i = 0; i < CONFIG.entities.agents; i++) {
                const agent = createEntity(0xff00ff, 0.15);
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.realms.ide.radius + 0.3 + Math.random() * (CONFIG.realms.meta.radius - CONFIG.realms.ide.radius - 0.5);

                agent.userData = {
                    type: 'agent',
                    angle: angle,
                    radius: radius,
                    speed: 0.4 + Math.random() * 0.5,
                    yOffset: (Math.random() - 0.5) * 0.8,
                    isPulling: false,
                    pullProgress: 0,
                    pullTarget: null,
                    pulsePhase: Math.random() * Math.PI * 2
                };

                // Create enhanced trail for agent
                const trailGeometry = new THREE.BufferGeometry();
                const trailPositions = new Float32Array(50 * 3);
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.userData = { positions: [] };
                agentTrails.push(trail);
                scene.add(trail);

                agents.push(agent);
                scene.add(agent);
            }
        }

        function createEntity(color, size) {
            const group = new THREE.Group();

            // Core sphere with physical material
            const coreGeometry = new THREE.SphereGeometry(size, 24, 24);
            const coreMaterial = new THREE.MeshPhysicalMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.2,
                metalness: 0.7,
                roughness: 0.2,
                clearcoat: 0.8,
                transparent: true,
                opacity: 0.95
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            // Glow sphere
            const glowGeometry = new THREE.SphereGeometry(size * 2, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.015,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);

            return group;
        }

        function createLatentParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles.latentCount;

            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = [];

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = CONFIG.realms.meta.radius + 0.5 + Math.random() * (CONFIG.realms.latent.radius - CONFIG.realms.meta.radius + 2);
                const y = (Math.random() - 0.5) * 4;

                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = Math.sin(angle) * radius;

                // More vibrant purple to cyan gradient
                const t = Math.random();
                colors[i * 3] = 0.4 + t * 0.4;
                colors[i * 3 + 1] = 0.2 + t * 0.5;
                colors[i * 3 + 2] = 0.9 + t * 0.1;

                sizes[i] = Math.random() * 4 + 1;

                velocities.push({
                    angle: angle,
                    radius: radius,
                    speed: 0.03 + Math.random() * 0.08,
                    ySpeed: (Math.random() - 0.5) * 0.015,
                    baseY: y,
                    phase: Math.random() * Math.PI * 2
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;

                    void main() {
                        vColor = customColor;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (250.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha = pow(alpha, 1.5);
                        gl_FragColor = vec4(vColor * 0.5, alpha * 0.05);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            latentParticles = new THREE.Points(geometry, material);
            latentParticles.userData = { velocities: velocities };
            scene.add(latentParticles);
        }

        function createDataStreams() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles.dataStreamCount;

            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const alphas = new Float32Array(count);
            const streamData = [];

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1 + Math.random() * 6;

                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1.5;
                positions[i * 3 + 2] = Math.sin(angle) * radius;

                // Varied data colors
                const colorType = Math.random();
                if (colorType < 0.6) {
                    // Cyan
                    colors[i * 3] = 0.3; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
                } else if (colorType < 0.8) {
                    // Green
                    colors[i * 3] = 0.3; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 0.5;
                } else {
                    // White
                    colors[i * 3] = 1.0; colors[i * 3 + 1] = 1.0; colors[i * 3 + 2] = 1.0;
                }

                sizes[i] = Math.random() * 4 + 1;
                alphas[i] = Math.random() * 0.25 + 0.15;

                streamData.push({
                    angle: angle,
                    radius: radius,
                    speed: 0.015 + Math.random() * 0.04,
                    radialSpeed: (Math.random() - 0.5) * 0.008,
                    y: positions[i * 3 + 1],
                    ySpeed: (Math.random() - 0.5) * 0.008
                });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: DataStreamShader.vertexShader,
                fragmentShader: DataStreamShader.fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            dataStreams = new THREE.Points(geometry, material);
            dataStreams.userData = { streamData: streamData };
            scene.add(dataStreams);
        }

        function createGridFloor() {
            const gridGroup = new THREE.Group();

            // Radial lines
            const radialCount = 48;
            for (let i = 0; i < radialCount; i++) {
                const angle = (i / radialCount) * Math.PI * 2;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    0, -0.5, 0,
                    Math.cos(angle) * 12, -0.5, Math.sin(angle) * 12
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.LineBasicMaterial({
                    color: 0x1a1a3a,
                    transparent: true,
                    opacity: 0.4
                });

                const line = new THREE.Line(geometry, material);
                gridGroup.add(line);
            }

            // Concentric circles
            for (let r = 1; r <= 12; r++) {
                const geometry = new THREE.BufferGeometry();
                const segments = 96;
                const positions = new Float32Array((segments + 1) * 3);

                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    positions[i * 3] = Math.cos(angle) * r;
                    positions[i * 3 + 1] = -0.5;
                    positions[i * 3 + 2] = Math.sin(angle) * r;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const opacity = r <= 8 ? 0.3 : 0.15;
                const material = new THREE.LineBasicMaterial({
                    color: 0x1a1a3a,
                    transparent: true,
                    opacity: opacity
                });

                const circle = new THREE.Line(geometry, material);
                gridGroup.add(circle);
            }

            scene.add(gridGroup);
        }

        function createLighting() {
            // Ambient light with subtle color
            const ambient = new THREE.AmbientLight(0x0a0a1a, 0.8);
            scene.add(ambient);

            // Core point light with shadows
            coreLight = new THREE.PointLight(0xff0044, 1.5, 15);
            coreLight.position.set(0, 0, 0);
            coreLight.castShadow = true;
            coreLight.shadow.mapSize.width = 512;
            coreLight.shadow.mapSize.height = 512;
            coreLight.shadow.radius = 4;
            scene.add(coreLight);

            // Realm accent lights
            const realmLights = [
                { color: 0x4a9eff, radius: 2.4, intensity: 1.5 },
                { color: 0x00ff88, radius: 4.0, intensity: 1.2 },
                { color: 0xff00ff, radius: 5.6, intensity: 1.0 },
                { color: 0x8844ff, radius: 7.5, intensity: 0.8 }
            ];

            realmLights.forEach((light, i) => {
                const pointLight = new THREE.PointLight(light.color, light.intensity, light.radius * 2.5);
                pointLight.position.set(0, 0.3, 0);
                scene.add(pointLight);
            });

            // Hemisphere light for better ambient
            const hemiLight = new THREE.HemisphereLight(0x0a0a2a, 0x000000, 0.5);
            scene.add(hemiLight);
        }

        function updateEntities(delta) {
            // Update normies
            normies.forEach(normie => {
                const data = normie.userData;
                data.angle += data.speed * delta;
                data.wobble += data.wobbleSpeed * delta;

                const wobbleOffset = Math.sin(data.wobble) * 0.1;
                const x = Math.cos(data.angle) * (data.radius + wobbleOffset);
                const z = Math.sin(data.angle) * (data.radius + wobbleOffset);
                const y = data.yOffset + Math.sin(data.wobble * 0.5) * 0.1;

                normie.position.set(x, y, z);

                // Pulse glow
                const pulse = Math.sin(time * 3 + data.pulsePhase) * 0.3 + 0.7;
                normie.children[1].material.opacity = 0.12 * pulse;
            });

            // Update operators
            operators.forEach((operator, index) => {
                const data = operator.userData;
                data.angle += data.speed * delta;

                const x = Math.cos(data.angle) * data.radius;
                const z = Math.sin(data.angle) * data.radius;
                const y = data.yOffset + Math.sin(time * 2 + index) * 0.15;

                operator.position.set(x, y, z);

                // Pulse glow
                const pulse = Math.sin(time * 2.5 + data.pulsePhase) * 0.3 + 0.7;
                operator.children[1].material.opacity = 0.12 * pulse;

                // Random connections to normies
                if (Math.random() < 0.003) {
                    data.connectionTarget = normies[Math.floor(Math.random() * normies.length)];
                    data.connectionStrength = 1;
                }
                data.connectionStrength *= 0.97;
            });

            // Update agents
            agents.forEach((agent, index) => {
                const data = agent.userData;
                data.angle += data.speed * delta;

                const x = Math.cos(data.angle) * data.radius;
                const z = Math.sin(data.angle) * data.radius;
                const y = data.yOffset + Math.sin(time * 1.5 + index) * 0.25;

                agent.position.set(x, y, z);

                // Pulse glow
                const pulse = Math.sin(time * 2 + data.pulsePhase) * 0.4 + 0.6;
                agent.children[1].material.opacity = 0.12 * pulse;

                // Update trail
                const trail = agentTrails[index];
                trail.userData.positions.unshift(agent.position.clone());
                if (trail.userData.positions.length > 50) {
                    trail.userData.positions.pop();
                }

                const trailPositions = trail.geometry.attributes.position.array;
                for (let i = 0; i < trail.userData.positions.length; i++) {
                    const pos = trail.userData.positions[i];
                    trailPositions[i * 3] = pos.x;
                    trailPositions[i * 3 + 1] = pos.y;
                    trailPositions[i * 3 + 2] = pos.z;
                }
                trail.geometry.attributes.position.needsUpdate = true;
                trail.geometry.setDrawRange(0, trail.userData.positions.length);

                // Latent space pulls
                if (!data.isPulling && Math.random() < 0.004) {
                    data.isPulling = true;
                    data.pullProgress = 0;
                    data.pullTarget = {
                        angle: data.angle + (Math.random() - 0.5) * 0.5,
                        radius: CONFIG.realms.latent.radius * (0.9 + Math.random() * 0.2)
                    };
                }

                if (data.isPulling) {
                    data.pullProgress += delta * 0.6;
                    if (data.pullProgress >= 1) {
                        data.isPulling = false;
                    }
                }
            });
        }

        function updateParticles(delta) {
            // Update latent particles
            if (latentParticles) {
                const positions = latentParticles.geometry.attributes.position.array;
                const velocities = latentParticles.userData.velocities;

                for (let i = 0; i < velocities.length; i++) {
                    const v = velocities[i];
                    v.angle += v.speed * delta;

                    positions[i * 3] = Math.cos(v.angle) * v.radius;
                    positions[i * 3 + 1] = v.baseY + Math.sin(time * 0.5 + v.phase) * 0.8;
                    positions[i * 3 + 2] = Math.sin(v.angle) * v.radius;
                }

                latentParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Update data streams
            if (dataStreams) {
                const positions = dataStreams.geometry.attributes.position.array;
                const streamData = dataStreams.userData.streamData;

                for (let i = 0; i < streamData.length; i++) {
                    const s = streamData[i];
                    s.angle += s.speed * delta;
                    s.radius += s.radialSpeed;
                    s.y += s.ySpeed;

                    if (s.radius < 1 || s.radius > 7) s.radialSpeed *= -1;
                    if (Math.abs(s.y) > 1.5) s.ySpeed *= -1;

                    positions[i * 3] = Math.cos(s.angle) * s.radius;
                    positions[i * 3 + 1] = s.y;
                    positions[i * 3 + 2] = Math.sin(s.angle) * s.radius;
                }

                dataStreams.geometry.attributes.position.needsUpdate = true;
            }

            // Rotate nebula slowly
            if (nebulaParticles) {
                nebulaParticles.rotation.y += delta * 0.01;
            }
        }

        function updateConnections() {
            // Remove old connection lines
            connectionLines.forEach(line => scene.remove(line));
            connectionLines = [];

            // Draw operator connections
            operators.forEach(operator => {
                const data = operator.userData;
                if (data.connectionStrength > 0.1 && data.connectionTarget) {
                    const start = operator.position;
                    const end = data.connectionTarget.position;

                    const midPoint = new THREE.Vector3(
                        (start.x + end.x) / 2,
                        Math.max(start.y, end.y) + 0.6,
                        (start.z + end.z) / 2
                    );

                    const curve = new THREE.QuadraticBezierCurve3(start, midPoint, end);
                    const points = curve.getPoints(30);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    const material = new THREE.LineBasicMaterial({
                        color: 0x00ff88,
                        transparent: true,
                        opacity: data.connectionStrength * 0.9,
                        blending: THREE.AdditiveBlending
                    });

                    const line = new THREE.Line(geometry, material);
                    connectionLines.push(line);
                    scene.add(line);

                    // Data packets
                    const packetCount = 4;
                    for (let i = 0; i < packetCount; i++) {
                        const t = ((time * 0.6 + i / packetCount) % 1);
                        const pos = curve.getPoint(t);

                        const packetGeometry = new THREE.SphereGeometry(0.035, 12, 12);
                        const packetMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: data.connectionStrength * (1 - t) * 1.2,
                            blending: THREE.AdditiveBlending
                        });
                        const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                        packet.position.copy(pos);
                        connectionLines.push(packet);
                        scene.add(packet);
                    }
                }
            });

            // Draw agent pull beams
            agents.forEach(agent => {
                const data = agent.userData;
                if (data.isPulling && data.pullTarget) {
                    const start = agent.position;
                    const targetX = Math.cos(data.pullTarget.angle) * data.pullTarget.radius;
                    const targetZ = Math.sin(data.pullTarget.angle) * data.pullTarget.radius;
                    const end = new THREE.Vector3(targetX, 0, targetZ);

                    const pullPoint = start.clone().lerp(end, data.pullProgress);

                    const geometry = new THREE.BufferGeometry().setFromPoints([start, pullPoint]);
                    const material = new THREE.LineBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.9,
                        blending: THREE.AdditiveBlending
                    });

                    const line = new THREE.Line(geometry, material);
                    connectionLines.push(line);
                    scene.add(line);

                    // Glow at pull point
                    if (data.pullProgress > 0.3) {
                        const glowGeometry = new THREE.SphereGeometry(0.12 * data.pullProgress, 16, 16);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: 0x8844ff,
                            transparent: true,
                            opacity: data.pullProgress * 0.8,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        glow.position.copy(pullPoint);
                        connectionLines.push(glow);
                        scene.add(glow);
                    }
                }
            });
        }

        function updateMatrixCore() {
            if (!matrixCore) return;

            // Enhanced pulse effect
            const pulse = 1 + Math.sin(time * 3) * 0.12;
            const pulse2 = 1 + Math.sin(time * 5) * 0.05;
            matrixCore.children[0].scale.setScalar(pulse * pulse2);
            matrixCore.children[1].scale.setScalar(pulse);
            matrixCore.children[2].scale.setScalar(1 + Math.sin(time * 2) * 0.15);

            // Rotate orbital rings
            for (let i = 3; i < matrixCore.children.length; i++) {
                const ring = matrixCore.children[i];
                const data = ring.userData;
                ring.rotateOnAxis(data.axis, data.rotationSpeed * 0.025);
            }

            // Pulse core light
            if (coreLight) {
                coreLight.intensity = 1.5 + Math.sin(time * 4) * 0.3;
            }
        }

        function updateRealmRings() {
            realmRings.forEach(ring => {
                ring.material.uniforms.time.value = time;
            });
        }

        function updateFPS() {
            frameCount++;
            if (time - lastFpsUpdate >= 1) {
                fpsElement.textContent = `FPS: ${frameCount}`;
                frameCount = 0;
                lastFpsUpdate = time;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            composer.passes.forEach(pass => {
                if (pass.uniforms && pass.uniforms.resolution) {
                    pass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                }
                if (pass.setSize) {
                    pass.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            time += delta;

            controls.update();

            updateEntities(delta);
            updateParticles(delta);
            updateConnections();
            updateMatrixCore();
            updateRealmRings();
            updateFPS();

            composer.passes.forEach(pass => {
                if (pass.uniforms && pass.uniforms.time) {
                    pass.uniforms.time.value = time;
                }
            });

            composer.render();
        }

        // Initialize
        init();
    </script>
</body>
</html>
